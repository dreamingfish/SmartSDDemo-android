package com.aisino.smartsd;

import java.util.Calendar;

import android.util.Log;

public class SmartSDSample {
	public static final int CASE4_FIX_DATA_LEN = 4096;
	public static final int CASE4_FIX_DATA_LEN_BASE = 512;
	public static final int CASE4_BLK_SIZE_DEFAULT = 0x08;

	public static final char TYPE_CASE1 = 0x01;
	public static final char TYPE_CASE2 = 0x02;
	public static final char TYPE_CASE3 = 0x03;
	public static final char TYPE_CASE4_START = 0x04;
	public static final char TYPE_CASE4_END = 0x0c;
	public static final char TYPE_CASE_BOOT = 0x05;

	public static final char SPICMD1[] = { 0x00, 0x20, 0x5A, 0xA5, 0x00 }; // case1
	public static final char SPICMD2[] = { 0x00, 0x40, 0x7A, 0x89, 0xFF }; // case2
	public static final char SPICMD3[] = {
			0x00,
			0x60,
			0x00,
			0x00,
			0xFF, // case3
			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
			0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
			0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
			0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
			0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
			0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c,
			0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62,
			0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
			0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
			0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
			0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
			0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
			0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
			0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
			0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
			0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
			0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
			0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
			0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
			0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
			0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
			0xfd, 0xFE };

	// case4
	public static final char SPI_EN_512[] = { 0x00, 0x80, 0x00, 0x01, 0x00 };
	public static final char SPI_UN_512[] = { 0x00, 0x8F, 0x00, 0x00, 0x00 };
	public static final char SPI_512[] = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
			0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
			0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b,
			0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
			0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
			0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c,
			0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52,
			0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d,
			0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
			0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
			0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
			0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
			0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94,
			0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
			0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa,
			0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5,
			0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0,
			0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,
			0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6,
			0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1,
			0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec,
			0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
			0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,

			0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
			0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
			0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
			0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b,
			0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
			0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
			0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c,
			0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62,
			0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d,
			0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
			0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
			0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
			0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
			0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4,
			0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
			0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba,
			0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5,
			0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0,
			0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
			0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6,
			0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1,
			0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
			0xfd, 0xfe, 0xff, // 512*1
	};
	public static final char SPI_result_512[] = { 0xA0, 0x42, 0x89, 0xD7, 0xB1,
			0x91, 0xE4, 0x8A, 0xAC, 0x07, 0x90, 0xE4, 0xBA, 0x66, 0x6A, 0x9A,
			0x25, 0x4F, 0x58, 0xA9, 0x4A, 0xB4, 0xCF, 0x0A, 0x7D, 0x84, 0xD6,
			0x02, 0x86, 0x34, 0x36, 0xDD, 0x26, 0x82, 0x98, 0xAB, 0x10, 0x28,
			0xC5, 0xCB, 0x03, 0x83, 0x35, 0x21, 0xEB, 0xC8, 0x8C, 0x2C, 0x48,
			0x9E, 0x58, 0x3F, 0x1B, 0x0A, 0x18, 0x97, 0xC2, 0x2E, 0x60, 0x1B,
			0x30, 0x3A, 0xB8, 0x62, 0xA7, 0xE4, 0xFD, 0xA6, 0x30, 0x3B, 0xC7,
			0xEC, 0xD7, 0x82, 0x68, 0x9F, 0x44, 0x3D, 0xA0, 0x8A, 0x27, 0x16,
			0x0F, 0x3A, 0x2C, 0xA0, 0xB1, 0x0C, 0xD2, 0xC9, 0xBF, 0xC2, 0x14,
			0xDD, 0x5E, 0x7B, 0x11, 0x36, 0x02, 0x61, 0x92, 0xB6, 0x30, 0xAC,
			0xA1, 0x48, 0xF0, 0x3B, 0x34, 0x3A, 0xAF, 0x11, 0x5D, 0xAA, 0xFD,
			0xC5, 0xA3, 0x11, 0x39, 0xA1, 0xE0, 0x84, 0x4A, 0xB9, 0xE8, 0x46,
			0x7C, 0xDA, 0x9A, 0x0D, 0x64, 0x11, 0xD5, 0x3F, 0x51, 0xA7, 0x0E,
			0x24, 0x90, 0x31, 0xAD, 0x96, 0x4D, 0x6D, 0x3B, 0xB8, 0xFA, 0x04,
			0xEA, 0x2E, 0x1F, 0x96, 0x42, 0x76, 0x3F, 0xDE, 0x11, 0x0F, 0x63,
			0x50, 0x9C, 0x1C, 0xF6, 0x17, 0x87, 0xC9, 0xE9, 0x57, 0xFC, 0x9B,
			0xEE, 0x45, 0xBB, 0x3E, 0x51, 0x35, 0x71, 0x2B, 0x72, 0x77, 0x0C,
			0x38, 0x27, 0xED, 0xB4, 0xA0, 0xC5, 0x6A, 0x07, 0x4E, 0xE1, 0xBE,
			0x62, 0x9E, 0xCF, 0xAA, 0xEB, 0x8D, 0x5E, 0x73, 0x36, 0x34, 0x54,
			0x12, 0xC1, 0x74, 0x05, 0xDC, 0xB0, 0xFE, 0x95, 0xE0, 0x33, 0x32,
			0xF9, 0x05, 0xB0, 0x2E, 0x09, 0x05, 0x2D, 0xDD, 0xFD, 0xED, 0x24,
			0x09, 0x8E, 0xEF, 0x91, 0x84, 0x95, 0xA7, 0x4E, 0x6E, 0x4B, 0xE4,
			0xFE, 0xCA, 0xF8, 0xC5, 0x10, 0x68, 0xB7, 0xC3, 0x34, 0x8C, 0xE6,
			0x87, 0x3B, 0x74, 0x17, 0x83, 0x1D, 0xC1, 0x64, 0x99,

			0xA0, 0x42, 0x89, 0xD7, 0xB1, 0x91, 0xE4, 0x8A, 0xAC, 0x07, 0x90,
			0xE4, 0xBA, 0x66, 0x6A, 0x9A, 0x25, 0x4F, 0x58, 0xA9, 0x4A, 0xB4,
			0xCF, 0x0A, 0x7D, 0x84, 0xD6, 0x02, 0x86, 0x34, 0x36, 0xDD, 0x26,
			0x82, 0x98, 0xAB, 0x10, 0x28, 0xC5, 0xCB, 0x03, 0x83, 0x35, 0x21,
			0xEB, 0xC8, 0x8C, 0x2C, 0x48, 0x9E, 0x58, 0x3F, 0x1B, 0x0A, 0x18,
			0x97, 0xC2, 0x2E, 0x60, 0x1B, 0x30, 0x3A, 0xB8, 0x62, 0xA7, 0xE4,
			0xFD, 0xA6, 0x30, 0x3B, 0xC7, 0xEC, 0xD7, 0x82, 0x68, 0x9F, 0x44,
			0x3D, 0xA0, 0x8A, 0x27, 0x16, 0x0F, 0x3A, 0x2C, 0xA0, 0xB1, 0x0C,
			0xD2, 0xC9, 0xBF, 0xC2, 0x14, 0xDD, 0x5E, 0x7B, 0x11, 0x36, 0x02,
			0x61, 0x92, 0xB6, 0x30, 0xAC, 0xA1, 0x48, 0xF0, 0x3B, 0x34, 0x3A,
			0xAF, 0x11, 0x5D, 0xAA, 0xFD, 0xC5, 0xA3, 0x11, 0x39, 0xA1, 0xE0,
			0x84, 0x4A, 0xB9, 0xE8, 0x46, 0x7C, 0xDA, 0x9A, 0x0D, 0x64, 0x11,
			0xD5, 0x3F, 0x51, 0xA7, 0x0E, 0x24, 0x90, 0x31, 0xAD, 0x96, 0x4D,
			0x6D, 0x3B, 0xB8, 0xFA, 0x04, 0xEA, 0x2E, 0x1F, 0x96, 0x42, 0x76,
			0x3F, 0xDE, 0x11, 0x0F, 0x63, 0x50, 0x9C, 0x1C, 0xF6, 0x17, 0x87,
			0xC9, 0xE9, 0x57, 0xFC, 0x9B, 0xEE, 0x45, 0xBB, 0x3E, 0x51, 0x35,
			0x71, 0x2B, 0x72, 0x77, 0x0C, 0x38, 0x27, 0xED, 0xB4, 0xA0, 0xC5,
			0x6A, 0x07, 0x4E, 0xE1, 0xBE, 0x62, 0x9E, 0xCF, 0xAA, 0xEB, 0x8D,
			0x5E, 0x73, 0x36, 0x34, 0x54, 0x12, 0xC1, 0x74, 0x05, 0xDC, 0xB0,
			0xFE, 0x95, 0xE0, 0x33, 0x32, 0xF9, 0x05, 0xB0, 0x2E, 0x09, 0x05,
			0x2D, 0xDD, 0xFD, 0xED, 0x24, 0x09, 0x8E, 0xEF, 0x91, 0x84, 0x95,
			0xA7, 0x4E, 0x6E, 0x4B, 0xE4, 0xFE, 0xCA, 0xF8, 0xC5, 0x10, 0x68,
			0xB7, 0xC3, 0x34, 0x8C, 0xE6, 0x87, 0x3B, 0x74, 0x17, 0x83, 0x1D,
			0xC1, 0x64, 0x99 };
	public static final char SPI_CMD_case4[] = { 0x00, 0x80, 0x01,
			CASE4_FIX_DATA_LEN / 512, 0x00 };
	public static final char SPI_END_case4[] = { 0x00, 0x8F, 0x01, 0x00, 0x00 };

	public int case4BlkSize = CASE4_BLK_SIZE_DEFAULT;

	private SmartSDDev SSDDev;

	public SmartSDSample() {
		SSDDev = new SmartSDDev();
	}

	public String getDllVersion() {
		return SSDDev.GetDllVer();
	}

	public int init(String driver) {
		Log.d("init", "path:" + driver);
		int uRet;
		uRet = SSDDev.IsSmartSD(driver);
		if (uRet == SmartSDDev.OK) {
			Log.d("init", "IsSmartSD succ..");
			try {
				Thread.sleep(300);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}

			uRet = SSDDev.EnSmartCardTrans();
			if (uRet != SmartSDDev.OK) {
				Log.d("init", "failed to EnSmartCardTrans");
				return SmartSDDev.ERR_FAIL;
			} else {
				Log.d("init", "succ to EnSmartCardTrans");
				return SmartSDDev.OK;
			}
		} else {
			Log.d("init", "IsSmartSD failed..");
			return SmartSDDev.ERR_FAIL;
		}
	}

	public int close() {
		if (SmartSDDev.OK == SSDDev.DisSmartCardTrans()) {
			return SmartSDDev.OK;
		} else {
			return SmartSDDev.ERR_FAIL;
		}
	}

	public String getVersion() {
		char[] verInfo = new char[CASE4_FIX_DATA_LEN];
		if (SmartSDDev.OK == SSDDev.MicroSD_GetCardInfo(verInfo)) {
			Log.d("getver", "succ to get card info..");
			StringBuilder sb = new StringBuilder();
			for (int i = 0; i < 12; i++) {
				sb.append(verInfo[i]);
			}
			// cid
			sb.append("\nCID:");
			sb.append(Utils.To_Hex(verInfo, 0x10, 0x20));
			Log.d("getver", "VersionInfo:" + sb.toString());
			return sb.toString();
		} else {
			Log.d("getver", "fail to get card info..");
		}

		return "";
	}

	public int reset() {
		int uRet;
		uRet = SSDDev.Controller_Rst();
		if (uRet == SmartSDDev.STATE_ERROR) {
			Log.d("reset", "state error.");
			return SmartSDDev.STATE_ERROR;
		} else if (uRet == SmartSDDev.STATE_BOOT) {
			Log.d("reset", "state boot.");
			return SmartSDDev.STATE_BOOT;
		} else if (uRet == SmartSDDev.STATE_APP) {
			Log.d("reset", "state app.");
			return SmartSDDev.STATE_APP;
		} else {
			Log.d("reset", "state:" + uRet);
			return SmartSDDev.STATE_ERROR;
		}
	}

	public int runapp() {
		int uRet;
		uRet = SSDDev.MicroSD_RunApp();
		if (uRet == SmartSDDev.OK) {
			Log.d("runapp", "succ to RunApp");
			return SmartSDDev.OK;
		} else {
			Log.d("runapp", "fail to RunApp");
			return SmartSDDev.ERR_FAIL;
		}
	}

	public int waitGetData(char pResp[], int pRespLen[], long waitMs) {
		int uRet = 0;
		long start = Calendar.getInstance().getTimeInMillis();
		pRespLen[0] = 0;
		while (0 == pRespLen[0]) {
			if (waitMs <= 0) {
				uRet = SSDDev.MicroSD_GetAPDUCommand(pRespLen, pResp);
			} else {
				if (waitMs < (Calendar.getInstance().getTimeInMillis() - start)) {
					return SmartSDDev.ERR_TIMEOUT;
				} else {
					uRet = SSDDev.MicroSD_GetAPDUCommand(pRespLen, pResp);
					if (0 == pRespLen[0]) {
						// Log.d("waitgetdata", "loop");
						try {
							Thread.sleep(waitMs / 100);
						} catch (InterruptedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			}
		}
		if (uRet == SmartSDDev.OK) {
			return SmartSDDev.OK;
		} else {
			return SmartSDDev.ERR_FAIL;
		}
	}

	public int case1_trans(char pCmd[], int pCmdLen, char pResp[],
			int pRespLen[], long waitMs) {
		int uRet = SSDDev.MicroSD_SendAPDUCommand(TYPE_CASE1, pCmdLen, pCmd);
		if (uRet != SmartSDDev.OK) {
			return SmartSDDev.ERR_WR_CMD_DAT;
		}
		return waitGetData(pResp, pRespLen, waitMs);
	}

	public int case2_trans(char pCmd[], int pCmdLen, char pResp[],
			int pRespLen[], long waitMs) {
		int uRet = SSDDev.MicroSD_SendAPDUCommand(TYPE_CASE2, pCmdLen, pCmd);
		if (uRet != SmartSDDev.OK) {
			return SmartSDDev.ERR_WR_CMD_DAT;
		}
		return waitGetData(pResp, pRespLen, waitMs);
	}

	public int case3_trans(char pCmd[], int pCmdLen, char pResp[],
			int pRespLen[], long waitMs) {
		int uRet = SSDDev.MicroSD_SendAPDUCommand(TYPE_CASE3, pCmdLen, pCmd);
		if (uRet != SmartSDDev.OK) {
			return SmartSDDev.ERR_WR_CMD_DAT;
		}
		return waitGetData(pResp, pRespLen, waitMs);
	}

	public int packageStart(char pCmd[], int pCmdLen, char pResp[],
			int pRespLen[], int case4FixLen, long waitMs) {
		if (pCmd == null || pResp == null) {
			return SmartSDDev.ERR_PARA;
		}

		int uRet = SSDDev.MicroSD_SendAPDUCommand(
				(char) (TYPE_CASE4_START | case4FixLen << 4), pCmdLen, pCmd);
		if (uRet != SmartSDDev.OK) {
			return SmartSDDev.ERR_WR_CMD_DAT;
		}

		return waitGetData(pResp, pRespLen, waitMs);
	}

	public int packageEnd(char pCmd[], int pCmdLen, char pResp[],
			int pRespLen[], long waitMs) {
		if (pCmd == null || pResp == null) {
			return SmartSDDev.ERR_PARA;
		}

		int uRet = SSDDev
				.MicroSD_SendAPDUCommand(TYPE_CASE4_END, pCmdLen, pCmd);
		if (uRet != SmartSDDev.OK) {
			return SmartSDDev.ERR_WR_CMD_DAT;
		}
		return waitGetData(pResp, pRespLen, waitMs);
	}

	public int case4_trans(char pCmd[], int pCmdLen, char pResp[], char pIn[],
			char pOut[], int case4FixLen, int round, char pCmd2[],
			int pCmdLen2, char pResp2[], long waitMs) {
		int respLen[] = new int[1];
		int nLen = 0;
		int uRet = packageStart(pCmd, pCmdLen, pResp, respLen, case4FixLen,
				waitMs);
		if (uRet != SmartSDDev.OK) {
			return uRet;
		}

		if ((0x90 != pResp[0]) || (0x00 != pResp[1])) {
			return SmartSDDev.ERR_WR_CMD_DAT;
		}

		// int pInCount = 0;
		// int pOutCount = 0;
		int count = round;

		nLen = case4FixLen * CASE4_FIX_DATA_LEN_BASE;
		int offset = 0;
		while (count-- > 0) {
			// char pOutTmp[] = new char[nLen];
			// char[] pInTmp = Utils.subarray(pIn, pInCount, nLen);
			char[] pInTmp = Utils.swapWordNew(pIn, offset, nLen);
			uRet = SSDDev.MicroSD_SendData(nLen, pInTmp);
			if (uRet != SmartSDDev.OK) {
				return SmartSDDev.ERR_WR_DATA;
			}
			// pInCount += nLen;

			long startTime = Calendar.getInstance().getTimeInMillis();
			while (true) {
				uRet = SSDDev.MicroSD_GetData(nLen, pInTmp);
				if (uRet == SmartSDDev.OK) {
					System.arraycopy(pInTmp, 0, pOut, offset, nLen);
					Utils.swapWord(pOut, offset, nLen);
					break;
				}
				if (uRet != SmartSDDev.ERR_TIMEOUT) {
					packageEnd(pCmd2, pCmdLen2, pResp2, respLen, waitMs);
					return SmartSDDev.ERR_RD_DATA;
				}

				if (waitMs > 0) {
					if (waitMs < (Calendar.getInstance().getTimeInMillis() - startTime)) {
						return SmartSDDev.ERR_TIMEOUT;
					}
					try {
						Thread.sleep(waitMs / 500);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
			// Utils.memcpy(pOut, pOutCount, pOutTmp, 0, nLen);
			// pOutCount += nLen;
			offset += nLen;
		}
		uRet = packageEnd(pCmd2, pCmdLen2, pResp2, respLen, waitMs);
		if (uRet == SmartSDDev.OK) {
			return SmartSDDev.OK;
		} else {
			return SmartSDDev.ERR_FAIL;
		}
	}
	
	//Size value must be 1-8
	public void setCase4BlkSize(int size) {
		if (size <= 0 || size > 8) {
			case4BlkSize = CASE4_BLK_SIZE_DEFAULT;
		} else {
			case4BlkSize = size;
		}
	}

	public int FMEncrypt(
			int u32Alg, 		//SM1
			int u32WorkMode, 	//CBC; ECB
			char[] pu8InBuf,	//明文
			int u32InLen,		//明文长度 
			char[] pu8OutBuf, 	//输出密文
			int pu32OutLen, 	//输出密文长度
			char[] pu8Key,		//外部输入密钥
			int u32KeyLen, 		//密钥长度
			char[] pu8IV,		//外部输入IV 
			int u32IVLen		//IV长度
			) 
	{
		int uRet;
		int[] resLen = new int[1];
		char[] SBuf = new char[576];
		char[] SBuf2 = new char[5];
		char[] RBuf = new char[4];
		if (pu8InBuf == null || pu8OutBuf == null || pu8Key == null
				|| pu8IV == null || (u32KeyLen + u32IVLen) > 0xff
				|| (u32WorkMode == 0 || u32WorkMode > 2)) {
			return SmartSDDev.ERR_PARA;
		}

		SBuf[0] = 0x00;
		SBuf[1] = 0x20;
		SBuf[2] = (char) (u32Alg & 0xff);
		SBuf[3] = (char) (u32WorkMode & 0xff);
		SBuf[4] = 0x00;
		uRet = case1_trans(SBuf, 5, RBuf, resLen, 10000);
		if (uRet != SmartSDDev.OK) {
			return uRet;
		}

		if ((0x90 != RBuf[0]) || (0x00 != RBuf[1])) {
			return ((RBuf[0] << 8) | RBuf[1]);
		}

		SBuf[0] = 0x00;
		SBuf[1] = 0x60;
		SBuf[2] = (char) (u32KeyLen & 0xff);
		SBuf[3] = (char) (u32IVLen & 0xff);
		SBuf[4] = (char) ((u32KeyLen + u32IVLen) & 0xff);
		char[] keyTmp = Utils.swapWordNew(pu8Key, 0, u32KeyLen);
		System.arraycopy(keyTmp, 0, SBuf, 5, u32KeyLen);
		char[] IVTmp = Utils.swapWordNew(pu8IV, 0, u32IVLen);
		System.arraycopy(IVTmp, 0, SBuf, 5 + u32KeyLen, u32IVLen);
		uRet = case3_trans(SBuf, 5 + u32KeyLen + u32IVLen, RBuf, resLen, 10000);
		if (uRet != SmartSDDev.OK) {
			return ((RBuf[0] << 8) | RBuf[1]);
		}
		if ((0x90 != RBuf[0]) || (0x00 != RBuf[1])) {
			return ((RBuf[0] << 8) | RBuf[1]);

		}

		SBuf[0] = 0x00;
		SBuf[1] = 0x80;
		SBuf[2] = 0x00;
		SBuf[3] = (char) (case4BlkSize & 0xff);
		SBuf[4] = 0x00;

		SBuf2[0] = 0x00;
		SBuf2[1] = 0x8f;
		SBuf2[2] = 0x00;
		SBuf2[3] = 0x00;
		SBuf2[4] = 0x00;
		uRet = case4_trans(SBuf, 5, RBuf, pu8InBuf, pu8OutBuf, case4BlkSize,
				u32InLen / (case4BlkSize * CASE4_FIX_DATA_LEN_BASE), SBuf2, 5,
				RBuf, 10000);
		if (uRet != SmartSDDev.OK) {
			return ((RBuf[0] << 8) | RBuf[1]);
		}
		if ((0x90 != RBuf[0]) || (0x00 != RBuf[1])) {
			return ((RBuf[0] << 8) | RBuf[1]);

		}

		return SmartSDDev.OK;
	}

	public int FMDecrypt(int u32Alg, int u32WorkMode, char[] pu8InBuf,
			int u32InLen, char[] pu8OutBuf, int pu32OutLen, char[] pu8Key,
			int u32KeyLen, char[] pu8IV, int u32IVLen) {
		int uRet;
		int[] resLen = new int[1];
		char[] SBuf = new char[576];
		char[] SBuf2 = new char[5];
		char[] RBuf = new char[4];
		if (pu8InBuf == null || pu8OutBuf == null || pu8Key == null
				|| pu8IV == null || (u32KeyLen + u32IVLen) > 0xff
				|| (u32WorkMode == 0 || u32WorkMode > 2)) {
			return SmartSDDev.ERR_PARA;
		}

		SBuf[0] = 0x00;
		SBuf[1] = 0x20;
		SBuf[2] = (char) (u32Alg & 0xff);
		SBuf[3] = (char) (u32WorkMode & 0xff);
		SBuf[4] = 0x00;
		uRet = case1_trans(SBuf, 5, RBuf, resLen, 10000);
		if (uRet != SmartSDDev.OK) {
			return uRet;
		}

		if ((0x90 != RBuf[0]) || (0x00 != RBuf[1])) {
			return ((RBuf[0] << 8) | RBuf[1]);
		}

		SBuf[0] = 0x00;
		SBuf[1] = 0x60;
		SBuf[2] = (char) (u32KeyLen & 0xff);
		SBuf[3] = (char) (u32IVLen & 0xff);
		SBuf[4] = (char) ((u32KeyLen + u32IVLen) & 0xff);
		char[] keyTmp = Utils.swapWordNew(pu8Key, 0, u32KeyLen);
		System.arraycopy(keyTmp, 0, SBuf, 5, u32KeyLen);
		char[] IVTmp = Utils.swapWordNew(pu8IV, 0, u32IVLen);
		System.arraycopy(IVTmp, 0, SBuf, 5 + u32KeyLen, u32IVLen);
		uRet = case3_trans(SBuf, 5 + u32KeyLen + u32IVLen, RBuf, resLen, 10000);
		if (uRet != SmartSDDev.OK) {
			return ((RBuf[0] << 8) | RBuf[1]);
		}
		if ((0x90 != RBuf[0]) || (0x00 != RBuf[1])) {
			return ((RBuf[0] << 8) | RBuf[1]);

		}

		SBuf[0] = 0x00;
		SBuf[1] = 0x80;
		SBuf[2] = 0x01;
		SBuf[3] = (char) (case4BlkSize & 0xff);
		SBuf[4] = 0x00;

		SBuf2[0] = 0x00;
		SBuf2[1] = 0x8f;
		SBuf2[2] = 0x00;
		SBuf2[3] = 0x00;
		SBuf2[4] = 0x00;
		uRet = case4_trans(SBuf, 5, RBuf, pu8InBuf, pu8OutBuf, case4BlkSize,
				u32InLen / (case4BlkSize * CASE4_FIX_DATA_LEN_BASE), SBuf2, 5,
				RBuf, 10000);
		if (uRet != SmartSDDev.OK) {
			return ((RBuf[0] << 8) | RBuf[1]);
		}
		if ((0x90 != RBuf[0]) || (0x00 != RBuf[1])) {
			return ((RBuf[0] << 8) | RBuf[1]);

		}

		return SmartSDDev.OK;
	}
}
